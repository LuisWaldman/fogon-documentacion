\subsubsection{Vista de procesos}\label{sec:vista-procesos}

La vista de procesos describe los aspectos dinámicos del sistema, incluyendo los procesos concurrentes, la comunicación entre ellos, y cómo el sistema maneja la sincronización y el rendimiento.

\paragraph{Procesos Principales}

\begin{itemize}
    \item \textbf{Proceso de Renderizado de UI:} Thread principal de la aplicación Vue.js que maneja el ciclo de vida de los componentes y la actualización del DOM.
    
    \item \textbf{Worker de Sincronización:} Maneja la conexión WebSocket con el servidor y procesa los mensajes de sincronización en tiempo real sin bloquear la UI.
    
    \item \textbf{Worker de Audio:} Procesa señales de audio para el afinador y genera eventos de audio para el metrónomo con precisión temporal.
    
    \item \textbf{Proceso Servidor (Golang):} Múltiples goroutines que manejan conexiones WebSocket, HTTP, y la lógica de distribución de estado.
\end{itemize}

\paragraph{Protocolo de Sincronización}

El desafío principal es mantener sincronizados los dispositivos cuando la latencia de red puede superar los 20ms (umbral de percepción humana).

\textbf{Mecanismo implementado:}

\begin{enumerate}
    \item \textbf{Sincronización de Relojes:} Al unirse a una sesión, los clientes sincronizan sus relojes con el servidor usando un protocolo simplificado similar a NTP:
    \begin{itemize}
        \item Cliente envía timestamp $t_1$
        \item Servidor responde con $t_1$, su timestamp $t_s$ y timestamp de respuesta $t_2$
        \item Cliente calcula offset: $offset = \frac{(t_2 - t_1) - (t_4 - t_3)}{2}$
        \item Se repite múltiples veces y se toma la mediana
    \end{itemize}
    
    \item \textbf{Broadcast de Eventos:} Cuando un usuario cambia el compás:
    \begin{itemize}
        \item Genera evento con timestamp sincronizado futuro ($t_{play} = t_{now} + \Delta$)
        \item Servidor broadcast a todos los clientes
        \item Cada cliente programa el cambio para $t_{play}$
    \end{itemize}
    
    \item \textbf{Buffer Adaptativo:} $\Delta$ se ajusta dinámicamente según la latencia medida de la sesión.
    
    \item \textbf{Compensación de Jitter:} Se implementa un buffer de reproducción que absorbe variaciones en la latencia, manteniendo la periodicidad del metrónomo.
\end{enumerate}

\paragraph{Comunicación entre Procesos}

\begin{itemize}
    \item \textbf{WebSocket:} Canal bidireccional para sincronización en tiempo real del estado compartido (compás, canción, lista).
    
    \item \textbf{WebRTC:} Propuesto para comunicación peer-to-peer en caso de falla del servidor o para reducir latencia en redes locales.
    
    \item \textbf{HTTP/REST:} Para operaciones no críticas en tiempo: búsqueda, carga/guardado de canciones, autenticación.
    
    \item \textbf{Message Bus interno:} Patrón Observer para comunicación entre componentes Vue.js.
\end{itemize}

\paragraph{Gestión de Concurrencia}

\begin{itemize}
    \item \textbf{En el Cliente:} JavaScript es single-threaded, pero usa Web Workers para procesamiento pesado (audio, sincronización) sin bloquear la UI.
    
    \item \textbf{En el Servidor:} Golang maneja concurrencia con goroutines y channels. Cada sesión tiene una goroutine dedicada que serializa las actualizaciones de estado, evitando race conditions.
    
    \item \textbf{Resolución de Conflictos:} En caso de eventos simultáneos, el servidor actúa como autoridad y resuelve mediante timestamps (el evento con timestamp menor gana).
\end{itemize}

% TODO: Agregar diagramas de secuencia para los escenarios principales
% \begin{figure}[h]
%     \centering
%     \includegraphics[width=\textwidth]{imagenes/diagrama-secuencia-sincronizacion.png}
%     \caption{Diagrama de secuencia: Protocolo de sincronización de compás}
%     \label{fig:secuencia-sincronizacion}
% \end{figure}cómo se comporta dinámicamente
\begin{itemize}
    \item Componente 1
    \item Componente 2
    \item Componente 3
\end{itemize}
